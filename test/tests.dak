(import [:nanoid [customAlphabet]]
        ["../index.dak" [Auth]])

(const apiKey "AIzaSyCnFgFqO3d7RbJDcNAp_eO21KSOISCP9IU")
(const nanoid (customAlphabet "abcdefghijklmnopqrstuvwxyz" 16))
(const domain "1secmail.com")

(fn@ sleep [delayMS] (Promise. #(setTimeout $ delayMS)))

(fn decodeHTML [html]
  (let [txt (document.createElement :textarea)]
    (set txt.innerHTML html)
    txt.value))

(fn encode-qs [params]
  (-> params
      Object.entries
      (.map (fn [[k v]] `${(encodeURIComponent k)}=${(encodeURIComponent v)}`))
      (.join "&")))

(fn@ secmail [params]
  (set params.domain domain)
  (-> `https://www.1secmail.com/api/v1/?${(encode-qs params)}`
      fetch await .json))

(fn@ getSigninLink [login]
  (let [list @(secmail {:action :getMessages :login login})]
    (when (zero? list.length)
      @(sleep 250)
      (return @(getSigninLink login)))
    (let [message @(secmail {:action :readMessage
                             :login login
                             :id (. list 0 :id)})
          link (?. (.exec #/'http.*oobCode.*'/ message.htmlBody) 0)]
      (when (not link)
        (throw (Error "link not found in email")))
      ; decode and trim leading and trailing single quote
      (-> link decodeHTML (.slice 1 -1)))))

(macro deftest [name ...body]
  '(QUnit.test name (fn@ [assert] ,...body)))

(deftest "email link signin"
  (let [login (nanoid)
        email `${login}@${domain}`
        states [#(assert.equal $ undefined  "start off without a user")
                #(assert.equal $?.email email "sign in")
                #(assert.equal $ undefined "account deleted")]
        done (assert.async states.length)
        auth @(Auth.new {:apiKey apiKey :name (nanoid)})
        count 0]
    (auth.subscribe
      (fn [user]
        (let [f (. states count)]
          (when (not f)
            (assert.ok false "unexpected assertion"))
          (++ count)
          (f user)
          (done))))
    ; complete the email sign in flow
    @(auth.sendEmailSigninLink email)
    @(auth.handleEmailSigninRedirect @(getSigninLink login))
    ; force a refresh by mucking with the data
    (set auth.user.expiresAt (- (Date.now) 10000))
    (let [old-expires auth.user.expiresAt]
      ; trigger a refresh
      (assert.ok @(auth.getBearerToken) "expect a bearer token")
      (assert.notEqual auth.user?.expiresAt old-expires "expires changes"))
    @(auth.delete)))

(deftest "email sign-up / sign-in"
  (let [login (nanoid)
        password (nanoid)
        email `${login}@${domain}`
        states [#(assert.equal $ undefined "start off without a user")
                #(assert.equal $?.email email "sign up")
                #(assert.equal $ undefined "sign out")
                #(assert.equal $?.email email "sign in")
                #(assert.equal $ undefined "account deleted")]
        done (assert.async states.length)
        auth @(Auth.new {:apiKey apiKey :name (nanoid)})
        count 0]
    (auth.subscribe
      (fn [user]
        (let [f (. states count)]
          (when (not f)
            (assert.ok false "unexpected assertion"))
          (++ count)
          (f user)
          (done))))
    ; complete the email/password flow
    @(auth.signUp {:email email :password password})
    @(auth.signOut)
    @(auth.signIn {:email email :password password})
    @(auth.delete)))

(deftest "subscribe with immediate = false"
  (let [login (nanoid)
        password (nanoid)
        email `${login}@${domain}`
        states [#(assert.equal $?.email email "sign up")
                #(assert.equal $ undefined "account deleted")]
        done (assert.async states.length)
        auth @(Auth.new {:apiKey apiKey :name (nanoid)})
        count 0]
    (auth.subscribe
      (fn [user]
        (let [f (. states count)]
          (when (not f)
            (assert.ok false "unexpected assertion"))
          (++ count)
          (f user)
          (done)))
      false)
    @(auth.signUp {:email email :password password})
    @(auth.delete)))
